use crate::{
    errors::{CrystalsError, EncryptionDecryptionError, KeyGenerationError, PackingError},
    indcpa::{
        generate_indcpa_key_pair, PrivateKey as IndcpaPrivateKey, PublicKey as IndcpaPublicKey,
    },
    params::{SecurityLevel, K, MAX_CIPHERTEXT, SHAREDSECRETBYTES, SYMBYTES},
};
use rand_chacha::ChaCha20Rng;
use rand_core::{CryptoRng, RngCore, SeedableRng};
use sha3::{
    digest::{ExtendableOutput, Update, XofReader},
    Digest, Sha3_256, Sha3_512, Shake256,
};
use subtle::{ConditionallySelectable, ConstantTimeEq};
use tinyvec::ArrayVec;

/// `PrivateKey` struct that can only be generated via the [`generate_key_pair`] function
/// and is used to [`decapsulate`](PrivateKey::decapsulate) a shared secret from a given ciphertext.
///
/// Can be accessed in byte form by packing into a `u8` array using the [`pack`](PrivateKey::pack) method, 
/// and made available for use again using the [`unpack`](PrivateKey::unpack) method. The 
/// array used to pack must be of the correct length for the given security level, see 
/// [`pack`](PrivateKey::pack) for more.
#[derive(Debug, Eq, PartialEq)]
pub struct PrivateKey {
    sk: IndcpaPrivateKey,
    pk: IndcpaPublicKey,
    h_pk: [u8; SYMBYTES],
    z: [u8; SYMBYTES],
}

/// `PublicKey` struct that can only be generated via the [`generate_key_pair`] or from the
/// corresponding [`PrivateKey`] struct using the [`get_public_key`](PrivateKey::get_public_key)
/// method and is used to [`encapsulate`](PublicKey::encapsulate) a shared secret.
///
/// Can be packed into a `u8` byte array using the [`pack`](PublicKey::pack) and 
/// [`unpack`](PublicKey::unpack) methods. The array used to pack must be of the correct length 
/// for the given secrity level, see [`pack`](PublicKey::pack) for more.
#[derive(Debug, Eq, PartialEq)]
pub struct PublicKey {
    pk: IndcpaPublicKey,
    h_pk: [u8; SYMBYTES],
}

/// `Ciphertext` struct that can only be generated by [`encapsulate`](PublicKey::encapsulate).
/// Should be converted to bytes using the [`as_bytes`](Ciphertext::as_bytes) method to be transmitted and decapsulated.
pub struct Ciphertext {
    bytes: [u8; MAX_CIPHERTEXT], // max ciphertext_bytes()
    len: usize,
}

impl Ciphertext {
    /// Returns a byte slice of the ciphertext
    ///
    /// # Example
    /// ```
    /// # use enc_rust::kem::*;
    /// # let (pk, sk) = generate_key_pair(None, 3).unwrap();
    /// let (ciphertext_obj, shared_secret) = pk.encapsulate(None, None)?;
    /// let ciphertext = ciphertext_obj.as_bytes();
    ///
    /// # Ok::<(), enc_rust::errors::EncryptionDecryptionError>(())
    /// ```
    #[must_use]
    pub fn as_bytes(&self) -> &[u8] {
        &self.bytes[..self.len]
    }
}

fn sha3_256_from(input: &[u8]) -> [u8; SYMBYTES] {
    let mut hash = Sha3_256::new();
    Digest::update(&mut hash, input);

    let output: [u8; SYMBYTES] = hash.finalize().into();
    output
}

fn sha3_512_from(input: &[u8]) -> ([u8; SHAREDSECRETBYTES], [u8; SYMBYTES]) {
    let mut hash = Sha3_512::new();
    Digest::update(&mut hash, input);
    let output = hash.finalize();

    let mut o1 = [0u8; SHAREDSECRETBYTES];
    let mut o2 = [0u8; SYMBYTES];

    o1.copy_from_slice(&output[..SHAREDSECRETBYTES]);
    o2.copy_from_slice(&output[SHAREDSECRETBYTES..]);
    (o1, o2)
}

fn shake256_from(input: &[u8]) -> [u8; SHAREDSECRETBYTES] {
    let mut hash = Shake256::default();
    hash.update(input);
    let mut output = [0u8; SHAREDSECRETBYTES];
    hash.finalize_xof().read(&mut output);
    output
}

// derived new keypair deterministically from a given 64 (2 * 32) byte seed.
fn new_key_from_seed(
    seed: &[u8],
    sec_level: SecurityLevel,
) -> Result<(PublicKey, PrivateKey), KeyGenerationError> {
    if seed.len() != 2 * SYMBYTES {
        return Err(CrystalsError::InvalidSeedLength(seed.len(), 2 * SYMBYTES).into());
    }

    let (sk, pk) = generate_indcpa_key_pair(&seed[..SYMBYTES], sec_level)?;

    let z: [u8; SYMBYTES] = seed[SYMBYTES..].try_into()?;

    let mut packed_pk = [0u8; MAX_CIPHERTEXT]; // max packed public key size
    pk.pack(&mut packed_pk[..sec_level.indcpa_public_key_bytes()])?;

    let h_pk: [u8; SYMBYTES] = sha3_256_from(&packed_pk[..sec_level.indcpa_public_key_bytes()]);

    Ok((PublicKey { pk, h_pk }, PrivateKey { sk, pk, h_pk, z }))
}

/// Acceptable RNG to be used in encapsulation and key generation must have the
/// [`RngCore`](https://docs.rs/rand_core/latest/rand_core/trait.RngCore.html) and
/// [`CryptoRng`](https://docs.rs/rand_core/latest/rand_core/trait.CryptoRng.html) traits.
pub trait AcceptableRng: RngCore + CryptoRng {}

/// Generates a new keypair for a given security level.
///
/// # Inputs
/// - `rng`: (Optional) RNG to be used when generating the keypair. Must satisfy the 
/// [`RngCore`](https://docs.rs/rand_core/latest/rand_core/trait.RngCore.html) and
/// [`CryptoRng`](https://docs.rs/rand_core/latest/rand_core/trait.CryptoRng.html) traits. 
/// If RNG is not present, then
/// [`ChaCha20`](https://docs.rs/rand_chacha/latest/rand_chacha/struct.ChaCha20Rng.html) 
/// will be used.
/// - `k`: The k value corresponding to the security value to be used:
///
/// | Security Level | K |
/// |----------------|---|
/// | 512            | 2 |
/// | 768            | 3 |
/// | 1024           | 4 |
///
/// # Outputs
/// - [`PublicKey`] object
/// - [`PrivateKey`] object
///
/// # Errors
/// Will return a [`KeyGenerationError`] if:
/// - Given invalid K value
/// - RNG fails
///
/// # Example
/// ```
/// # use enc_rust::kem::*;
/// let (pk, sk) = generate_key_pair(None, 3)?;
///
/// # Ok::<(), enc_rust::errors::KeyGenerationError>(())
/// ```
pub fn generate_key_pair(
    rng: Option<&mut dyn AcceptableRng>,
    k: usize,
) -> Result<(PublicKey, PrivateKey), KeyGenerationError> {
    let k_result = K::try_from(k);

    if let Ok(k_value) = k_result {
        let mut seed = [0u8; 2 * SYMBYTES];

        if let Some(rng) = rng {
            rng.try_fill_bytes(&mut seed)?;
        } else {
            let mut chacha = ChaCha20Rng::from_entropy();
            chacha.try_fill_bytes(&mut seed)?;
        };

        let sec_level = SecurityLevel::new(k_value);

        return new_key_from_seed(&seed, sec_level);
    }

    Err(CrystalsError::InvalidK(k).into())
}

impl PrivateKey {
    pub(crate) const fn sec_level(&self) -> SecurityLevel {
        self.sk.sec_level()
    }

    /// Returns the corresponding public key for a given private key
    ///
    /// # Example
    /// ```
    /// # use enc_rust::kem::*;
    /// let (_, sk) = generate_key_pair(None, 3)?;
    /// let pk = sk.get_public_key();
    ///
    /// # Ok::<(), enc_rust::errors::KeyGenerationError>(())
    /// ```
    #[must_use]
    pub const fn get_public_key(&self) -> PublicKey {
        PublicKey {
            pk: self.pk,
            h_pk: self.h_pk,
        }
    }

    /// Packs private key into a given buffer
    ///
    /// # Inputs
    /// - `bytes`: Buffer for the private key to be packed into. For corresponding
    /// security levels, `bytes` should be of length:
    ///
    /// | Security Level | Length |
    /// |----------------|--------|
    /// | 512            | 1632   |
    /// | 768            | 2400   |
    /// | 1024           | 3168   |
    ///
    /// # Errors
    /// Will return a [`PackingError`] if the buffer is of the wrong length
    ///
    /// # Example
    /// ```
    /// # use enc_rust::kem::*;
    /// let (_, sk) = generate_key_pair(None, 3).unwrap();
    /// let mut sk_bytes = [0u8; 2400];
    /// sk.pack(&mut sk_bytes)?;
    ///
    /// # Ok::<(), enc_rust::errors::PackingError>(())
    /// ```
    pub fn pack(&self, bytes: &mut [u8]) -> Result<(), PackingError> {
        let sec_level = self.sec_level();

        if bytes.len() != sec_level.private_key_bytes() {
            return Err(CrystalsError::IncorrectBufferLength(
                bytes.len(),
                sec_level.private_key_bytes(),
            )
            .into());
        }

        let (sk_bytes, rest) = bytes.split_at_mut(sec_level.indcpa_private_key_bytes());
        let (pk_bytes, rest) = rest.split_at_mut(sec_level.indcpa_public_key_bytes());
        let (h_pk_bytes, z_bytes) = rest.split_at_mut(SYMBYTES);
        self.sk.pack(sk_bytes)?;
        self.pk.pack(pk_bytes)?;
        h_pk_bytes.copy_from_slice(&self.h_pk);
        z_bytes.copy_from_slice(&self.z);

        Ok(())
    }

    /// Unpacks a buffer of bytes into a [`PrivateKey`]
    ///
    /// # Inputs
    /// - `bytes`: Buffer for the private key to be extracted from
    ///
    /// # Outputs
    /// - [`PrivateKey`] object
    ///
    /// # Errors
    /// Will return a [`PackingError`] if the buffer is of the wrong length
    ///
    /// # Example
    /// ```
    /// # use enc_rust::kem::*;
    /// # let (pk, new_sk) = generate_key_pair(None, 3).unwrap();
    /// # let mut sk_bytes = [0u8; 2400];
    /// # new_sk.pack(&mut sk_bytes)?;
    /// let sk = PrivateKey::unpack(&sk_bytes)?;
    ///
    /// # Ok::<(), enc_rust::errors::PackingError>(())
    /// ```
    pub fn unpack(bytes: &[u8]) -> Result<Self, PackingError> {
        let sec_level = match bytes.len() {
            1632 => SecurityLevel::new(K::Two),
            2400 => SecurityLevel::new(K::Three),
            3168 => SecurityLevel::new(K::Four),
            _ => return Err(CrystalsError::IncorrectBufferLength(bytes.len(), 3168).into()),
        };
        let (sk_bytes, rest) = bytes.split_at(sec_level.indcpa_private_key_bytes());
        let (pk_bytes, rest) = rest.split_at(sec_level.indcpa_public_key_bytes());
        let (h_pk_bytes, z_bytes) = rest.split_at(SYMBYTES);

        let sk = IndcpaPrivateKey::unpack(sk_bytes)?;
        let pk = IndcpaPublicKey::unpack(pk_bytes)?;
        let mut h_pk = [0u8; SYMBYTES];
        h_pk.copy_from_slice(h_pk_bytes);
        let mut z = [0u8; SYMBYTES];
        z.copy_from_slice(z_bytes);

        Ok(Self { sk, pk, h_pk, z })
    }

    /// Decapsulates a ciphertext (given as a byte slice) into the shared secret
    ///
    /// # Inputs
    /// - `ciphertext`: Byte slice containing the ciphertext to be decapsulated
    ///
    /// # Outputs
    /// - `[u8; 32]`: The shared secret, a 32 byte array
    ///
    /// # Errors
    /// Will return an [`EncryptionDecryptionError`] if:
    /// - Given invalid ciphertext length
    ///
    /// # Example
    /// ```
    /// # use enc_rust::kem::*;
    /// # let (pk, sk) = generate_key_pair(None, 3).unwrap();
    /// # let (ciphertext_obj, secret) = pk.encapsulate(None, None).unwrap();
    /// # let ciphertext = ciphertext_obj.as_bytes();
    /// let shared_secret = sk.decapsulate(ciphertext)?;
    ///
    /// # Ok::<(), enc_rust::errors::EncryptionDecryptionError>(())
    /// ```
    pub fn decapsulate(
        &self,
        ciphertext: &[u8],
    ) -> Result<[u8; SHAREDSECRETBYTES], EncryptionDecryptionError> {
        let sec_level = self.sec_level();

        if ciphertext.len() != sec_level.ciphertext_bytes() {
            return Err(CrystalsError::InvalidCiphertextLength(
                ciphertext.len(),
                sec_level.ciphertext_bytes(),
                sec_level.k(),
            )
            .into());
        }

        let m = self.sk.decrypt(ciphertext)?;

        let (k, r) = sha3_512_from(&[m, self.h_pk].concat());

        let k_bar = shake256_from(&[&self.z, ciphertext].concat());

        let mut ct = [0u8; MAX_CIPHERTEXT]; // max indcpa_bytes()
        self.pk
            .encrypt(&m, &r, &mut ct[..sec_level.indcpa_bytes()])?;

        let equal = ct.ct_eq(ciphertext);

        Ok(k.iter()
            .zip(k_bar.iter())
            .map(|(x, y)| u8::conditional_select(x, y, equal))
            .collect::<ArrayVec<[u8; SHAREDSECRETBYTES]>>()
            .into_inner())
    }
}

impl PublicKey {
    pub(crate) const fn sec_level(&self) -> SecurityLevel {
        self.pk.sec_level()
    }

    /// Packs [`PublicKey`] into a given buffer
    ///
    /// # Inputs
    /// - `bytes`: Buffer for the public key to be packed into. For corresponding
    /// security levels, `bytes` should be of length:
    ///
    /// | Security Level | Length |
    /// |----------------|--------|
    /// | 512            | 800    |
    /// | 768            | 1184   |
    /// | 1024           | 1568   |
    ///
    /// # Errors
    /// Will return a [`PackingError`] if the buffer is of the wrong length
    ///
    /// # Example
    /// ```
    /// # use enc_rust::kem::*;
    /// # let (pk, sk) = generate_key_pair(None, 3).unwrap();
    /// let mut pk_bytes = [0u8; 1184];
    /// pk.pack(&mut pk_bytes)?;
    ///
    /// # Ok::<(), enc_rust::errors::PackingError>(())
    /// ```
    pub fn pack(&self, bytes: &mut [u8]) -> Result<(), PackingError> {
        if bytes.len() != self.sec_level().public_key_bytes() {
            return Err(CrystalsError::IncorrectBufferLength(
                bytes.len(),
                self.sec_level().public_key_bytes(),
            )
            .into());
        }

        self.pk.pack(bytes)?;

        Ok(())
    }

    /// Unpacks a buffer of bytes into a [`PublicKey`]
    ///
    /// # Inputs
    /// - `bytes`: Buffer for the public key to be extracted from
    ///
    /// # Outputs
    /// - [`PublicKey`] object
    ///
    /// # Errors
    /// Will return a [`PackingError`] if the buffer is of the wrong length
    ///
    /// # Example
    /// ```
    /// # use enc_rust::kem::*;
    /// # let (new_pk, sk) = generate_key_pair(None, 3).unwrap();
    /// # let mut pk_bytes = [0u8; 1184];
    /// # new_pk.pack(&mut pk_bytes)?;
    /// let pk = PublicKey::unpack(&pk_bytes)?;
    ///
    /// # Ok::<(), enc_rust::errors::PackingError>(())
    /// ```
    pub fn unpack(bytes: &[u8]) -> Result<Self, PackingError> {
        let pk = IndcpaPublicKey::unpack(bytes)?;
        let h_pk = sha3_256_from(bytes);

        Ok(Self { pk, h_pk })
    }

    /// Encapsulates a generated shared secret into a ciphertext to be shared
    ///
    /// # Inputs
    /// - `seed`: (Optional) a 64 byte slice used as a seed for randomness
    /// - `rng`: (Optional) RNG to be used during encapsulation. Must satisfy the 
    /// [`RngCore`](https://docs.rs/rand_core/latest/rand_core/trait.RngCore.html) and
    /// [`CryptoRng`](https://docs.rs/rand_core/latest/rand_core/trait.CryptoRng.html) traits. 
    /// If RNG is not present, then
    /// [`ChaCha20`](https://docs.rs/rand_chacha/latest/rand_chacha/struct.ChaCha20Rng.html) 
    /// will be used.
    ///
    /// # Outputs
    /// - [`Ciphertext`] object
    /// - `[u8; 32]`: The shared secret, a 32 byte array
    ///
    /// # Errors
    /// Will return an [`EncryptionDecryptionError`] if:
    /// - Given invalid seed length
    /// - RNG fails
    ///
    /// # Example
    /// ```
    /// # use enc_rust::kem::*;
    /// # let (pk, sk) = generate_key_pair(None, 3).unwrap();
    /// let (ciphertext_obj, shared_secret) = pk.encapsulate(None, None)?;
    ///
    /// # Ok::<(), enc_rust::errors::EncryptionDecryptionError>(())
    /// ```
    pub fn encapsulate(
        &self,
        seed: Option<&[u8]>,
        rng: Option<&mut dyn AcceptableRng>,
    ) -> Result<(Ciphertext, [u8; SHAREDSECRETBYTES]), EncryptionDecryptionError> {
        let sec_level = self.pk.sec_level();

        let mut m = [0u8; SYMBYTES];
        if let Some(seed) = seed {
            if seed.len() != SYMBYTES {
                return Err(CrystalsError::InvalidSeedLength(seed.len(), SYMBYTES).into());
            }
            m.copy_from_slice(seed);
        } else if let Some(rng) = rng {
            rng.try_fill_bytes(&mut m)?;
        } else {
            let mut chacha = ChaCha20Rng::from_entropy();
            chacha.try_fill_bytes(&mut m)?;
        }

        let (k, r) = sha3_512_from(&[m, self.h_pk].concat());
        let mut bytes = [0u8; MAX_CIPHERTEXT]; // max ciphertext_bytes
        self.pk
            .encrypt(&m, &r, &mut bytes[..sec_level.ciphertext_bytes()])?;

        Ok((
            Ciphertext {
                bytes,
                len: sec_level.ciphertext_bytes(),
            },
            k,
        ))
    }
}
